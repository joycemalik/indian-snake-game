<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cursor Snake - Apple Collector</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            cursor: none; /* Hide default cursor */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');

        let WIDTH, HEIGHT;

        // Game Constants
        const SEGMENT_SIZE = 12; // Visual size of each snake segment
        const APPLE_SIZE = 20;   // Visual size of the apple (adjusted for image)
        const INITIAL_SNAKE_LENGTH = 15; // Number of segments
        const INITIAL_SPEED = 250; // Pixels per second
        const SPEED_INCREASE_RATE = 10; // Pixels per second increase per second
        const FOLLOW_FACTOR = 0.08; // How "tightly" segments follow the previous one (0.01-0.2 usually)
        const AI_SPEED_FACTOR = 0.9; // AI snake speed relative to player
        const AI_TARGET_CHANGE_DIST_SQ = 150 * 150; // Squared distance for AI to pick new target
        const AI_TARGET_LIFESPAN = 5000; // ms, max time for an AI target to stay before picking a new one
        const SCORE_PER_APPLE = 10; // Points awarded for collecting an apple

        // Apple Image Asset
        const APPLE_IMAGE = new Image();
        APPLE_IMAGE.src = 'data:image/png;base64,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';
        let appleImageLoaded = false;

        // Game State
        let playerSnake = [];
        let aiSnake = [];
        let apple = { x: 0, y: 0 }; // Position of the apple
        let score = 0; // Player's score
        let cursorPos = { x: 0, y: 0 };
        let gameSpeed = INITIAL_SPEED;
        let lastFrameTime = 0;
        let gameStartTime = 0;
        let aiTarget = { x: 0, y: 0 };
        let aiTargetSetTime = 0;

        /**
         * Initializes the game. Sets up canvas, snakes, apple, and event listeners.
         */
        function init() {
            onResize(); // Set initial canvas size
            window.addEventListener('resize', onResize);
            document.addEventListener('mousemove', onMouseMove);

            // Set onload for the apple image
            APPLE_IMAGE.onload = () => {
                appleImageLoaded = true;
            };
            // Handle potential error loading image (optional)
            APPLE_IMAGE.onerror = () => {
                console.error("Failed to load apple image.");
                appleImageLoaded = false; // Ensure fallback is used
            };

            // Initialize snakes with a slight offset
            playerSnake = createSnake(WIDTH / 2 - 50, HEIGHT / 2, INITIAL_SNAKE_LENGTH);
            aiSnake = createSnake(WIDTH / 2 + 50, HEIGHT / 2, INITIAL_SNAKE_LENGTH);

            // Set initial game time, AI target, and apple position
            gameStartTime = performance.now();
            setNewAITarget();
            spawnApple(); // Place the first apple

            // Start the game loop
            requestAnimationFrame(gameLoop);
        }

        /**
         * Creates a new snake with specified starting position and length.
         * @param {number} startX - X coordinate for the head.
         * @param {number} startY - Y coordinate for the head.
         * @param {number} length - Number of segments.
         * @returns {Array<{x: number, y: number}>} - Array of snake segments.
         */
        function createSnake(startX, startY, length) {
            const snake = [];
            for (let i = 0; i < length; i++) {
                // Initial offset for visual separation between segments
                snake.push({ x: startX - i * SEGMENT_SIZE * 0.8, y: startY });
            }
            return snake;
        }

        /**
         * Main game loop, called on each animation frame.
         * @param {DOMHighResTimeStamp} currentTime - Current time provided by requestAnimationFrame.
         */
        function gameLoop(currentTime) {
            if (!lastFrameTime) {
                lastFrameTime = currentTime;
            }
            const deltaTime = (currentTime - lastFrameTime) / 1000; // Time in seconds
            lastFrameTime = currentTime;

            const elapsedTime = (currentTime - gameStartTime) / 1000; // Time in seconds since game start
            gameSpeed = INITIAL_SPEED + elapsedTime * SPEED_INCREASE_RATE;

            // Update Player Snake (head follows cursor)
            moveSnakeHead(playerSnake, cursorPos.x, cursorPos.y, deltaTime, 1.0);
            updateSnakeSegments(playerSnake);

            // Update AI Snake (head follows random targets)
            const aiHead = aiSnake[0];
            const distToAITargetSq = (aiTarget.x - aiHead.x) ** 2 + (aiTarget.y - aiHead.y) ** 2;
            if (distToAITargetSq < AI_TARGET_CHANGE_DIST_SQ || (currentTime - aiTargetSetTime) > AI_TARGET_LIFESPAN) {
                setNewAITarget(); // Pick a new target if reached or timed out
            }
            moveSnakeHead(aiSnake, aiTarget.x, aiTarget.y, deltaTime, AI_SPEED_FACTOR);
            updateSnakeSegments(aiSnake);

            // Check for apple collision with player snake
            const playerHead = playerSnake[0];
            const distToAppleSq = (apple.x - playerHead.x) ** 2 + (apple.y - playerHead.y) ** 2;
            // Collision threshold: sum of radii squared
            const collisionThresholdSq = ((SEGMENT_SIZE / 2) + (APPLE_SIZE / 2)) ** 2;

            if (distToAppleSq < collisionThresholdSq) {
                score += SCORE_PER_APPLE;
                // Add a new segment to the snake at the position of the last segment
                const lastSegment = playerSnake[playerSnake.length - 1];
                playerSnake.push({ x: lastSegment.x, y: lastSegment.y });
                spawnApple(); // Respawn the apple
            }

            draw(); // Redraw everything

            requestAnimationFrame(gameLoop);
        }

        /**
         * Moves the head of a snake towards a target position, handling screen wrap-around.
         * @param {Array<{x: number, y: number}>} snake - The snake to move.
         * @param {number} targetX - X coordinate of the target.
         * @param {number} targetY - Y coordinate of the target.
         * @param {number} dt - Delta time in seconds.
         * @param {number} speedMultiplier - Multiplier for the current game speed.
         */
        function moveSnakeHead(snake, targetX, targetY, dt, speedMultiplier) {
            let head = snake[0];
            const actualMoveDistance = gameSpeed * dt * speedMultiplier;

            // Calculate dx, dy considering wrap-around for the shortest path
            let dx = targetX - head.x;
            let dy = targetY - head.y;

            if (Math.abs(dx) > WIDTH / 2) {
                dx = (targetX > head.x) ? dx - WIDTH : dx + WIDTH;
            }
            if (Math.abs(dy) > HEIGHT / 2) {
                dy = (targetY > head.y) ? dy - HEIGHT : dy + HEIGHT;
            }
            
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
                // Ensure the snake doesn't overshoot the target if it's very close
                const moveAmount = Math.min(distance, actualMoveDistance);
                head.x += (dx / distance) * moveAmount;
                head.y += (dy / distance) * moveAmount;
            }

            // Apply wrap-around to head position directly after movement
            if (head.x < 0) head.x += WIDTH;
            if (head.x > WIDTH) head.x -= WIDTH;
            if (head.y < 0) head.y += HEIGHT;
            if (head.y > HEIGHT) head.y -= HEIGHT;
        }

        /**
         * Updates the positions of snake segments to smoothly follow the preceding segment.
         * Handles wrap-around for smooth following across screen edges.
         * @param {Array<{x: number, y: number}>} snake - The snake whose segments to update.
         */
        function updateSnakeSegments(snake) {
            for (let i = 1; i < snake.length; i++) {
                const prev = snake[i - 1];
                const curr = snake[i];

                let dx = prev.x - curr.x;
                let dy = prev.y - curr.y;

                // Adjust dx, dy for shortest path considering wrap-around
                if (Math.abs(dx) > WIDTH / 2) {
                    dx = (prev.x > curr.x) ? dx - WIDTH : dx + WIDTH;
                }
                if (Math.abs(dy) > HEIGHT / 2) {
                    dy = (prev.y > curr.y) ? dy - HEIGHT : dy + HEIGHT;
                }

                // Apply a fraction of the distance for smooth, spring-like following
                curr.x += dx * FOLLOW_FACTOR;
                curr.y += dy * FOLLOW_FACTOR;

                // Ensure segments also wrap around after movement
                if (curr.x < 0) curr.x += WIDTH;
                if (curr.x > WIDTH) curr.x -= WIDTH;
                if (curr.y < 0) curr.y += HEIGHT;
                if (curr.y > HEIGHT) curr.y -= HEIGHT;
            }
        }

        /**
         * Sets a new random target for the AI snake within canvas bounds.
         */
        function setNewAITarget() {
            aiTarget.x = Math.random() * WIDTH;
            aiTarget.y = Math.random() * HEIGHT;
            aiTargetSetTime = performance.now();
        }

        /**
         * Places the apple at a new random position on the canvas.
         */
        function spawnApple() {
            // Ensure apple spawns slightly away from edges
            apple.x = Math.random() * (WIDTH - APPLE_SIZE * 2) + APPLE_SIZE;
            apple.y = Math.random() * (HEIGHT - APPLE_SIZE * 2) + APPLE_SIZE;
        }

        /**
         * Draws all game elements on the canvas.
         */
        function draw() {
            // Clear canvas
            CTX.clearRect(0, 0, WIDTH, HEIGHT);

            // Draw Player Snake (Green)
            drawSnake(playerSnake, '#4CAF50'); // Green

            // Draw AI Snake (Red)
            drawSnake(aiSnake, '#F44336'); // Red

            // Draw the Apple
            drawApple(apple);

            // Draw the Score
            drawScore();

            // Draw a subtle dot for the AI target (optional, for debugging/visualizing AI intent)
            // CTX.fillStyle = 'rgba(255, 255, 255, 0.2)';
            // CTX.beginPath();
            // CTX.arc(aiTarget.x, aiTarget.y, SEGMENT_SIZE / 2, 0, Math.PI * 2);
            // CTX.fill();
        }

        /**
         * Draws a single snake composed of circular segments.
         * @param {Array<{x: number, y: number}>} snake - The snake to draw.
         * @param {string} color - The color of the snake.
         */
        function drawSnake(snake, color) {
            CTX.fillStyle = color;
            snake.forEach((segment, index) => {
                CTX.beginPath();
                // Make head slightly larger for visual distinction
                const currentSegmentSize = (index === 0) ? SEGMENT_SIZE * 1.2 : SEGMENT_SIZE;
                CTX.arc(segment.x, segment.y, currentSegmentSize / 2, 0, Math.PI * 2);
                CTX.fill();
            });
        }

        /**
         * Draws the apple on the canvas.
         * @param {{x: number, y: number}} apple - The apple object to draw.
         */
        function drawApple(apple) {
            if (appleImageLoaded) {
                // Draw the image centered at the apple's x, y
                CTX.drawImage(APPLE_IMAGE, apple.x - APPLE_SIZE / 2, apple.y - APPLE_SIZE / 2, APPLE_SIZE, APPLE_SIZE);
            } else {
                // Fallback to drawing a circle if image not loaded
                CTX.fillStyle = '#FF5722'; // Orange-red color for apple
                CTX.beginPath();
                CTX.arc(apple.x, apple.y, APPLE_SIZE / 2, 0, Math.PI * 2);
                CTX.fill();
            }
        }

        /**
         * Draws the current score on the canvas.
         */
        function drawScore() {
            CTX.fillStyle = '#FFFFFF'; // White text
            CTX.font = '24px Arial';
            CTX.textAlign = 'left';
            CTX.fillText(`Score: ${score}`, 10, 30); // Top-left corner
        }

        /**
         * Handles mouse movement to update the player snake's target position.
         * @param {MouseEvent} event - The mouse event.
         */
        function onMouseMove(event) {
            cursorPos.x = event.clientX;
            cursorPos.y = event.clientY;
        }

        /**
         * Handles window resize events to adjust canvas dimensions to fill the screen.
         */
        function onResize() {
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            CANVAS.width = WIDTH;
            CANVAS.height = HEIGHT;
        }

        // Initialize the game when the script loads
        init();
    </script>
</body>
</html>